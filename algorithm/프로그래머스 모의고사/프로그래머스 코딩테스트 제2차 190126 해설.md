##### [응시자 평균 점수]

|           | 만점자 비율 | 평균 점수 |
| --------- | ----------- | --------- |
| 배열 회전 | 72%         | 93.137255 |
| 가로등    | 56%         | 83.537906 |
| 빙고      | 41%         | 76.082677 |

#### [점수대별 기업 코딩테스트 합격 가능성]

| 점수       | 채용 코딩테스트 합격 가능성                    |
| ---------- | ---------------------------------------------- |
| 200점 이상 | 대부분의 코딩테스트에서 합격할 확률이 높습니다 |
| 150~200점  | 탈락하는 코딩테스트가 있을 수 있습니다.        |
| 100~150점  | 조금만 더 노력하시면 좋겠네요.                 |
| 100점 이하 | 프로그래머스와 함께 조금 더 공부해볼까요?      |

- 가장 평균적인 코딩테스트 난이도를 기준으로 작성한 내용이므로 모든 회사의 코딩테스트에 적용할 수는 없습니다. 참고용으로만 활용하세요.

------

### 배열 회전

> 배열의 회전이란 모든 원소를 오른쪽으로 한 칸씩 이동시키고, 마지막 원소는 배열의 맨 앞에 넣는 것을 말합니다. 두 배열 arrA와 arrB가 매개변수로 주어질 때, arrA를 회전해 arrB로 만들 수 있으면 true를, 그렇지 않으면 false를 return 하는 solution 함수를 작성해주세요.

반복문을 사용할 수 있는지 물어보는 문제입니다. 아주 기초적인 문제이니 어렵지 않게 풀 수 있었을거에요.

권장 Time complexity: O( n2 )

▼ 정답 예시

```
def rotate(arr):
    return arr[-1:] + arr[:-1]

def solution(arrA, arrB):
    arrA_len = len(arrA)
    arrB_len = len(arrB)

    # 길이가 다른 배열은 회전해도 같아질 수 없으므로, early return
    if(arrA_len!=arrB_len):
        return False

    # arrA를 한칸씩 회전하며, arrB와 같은지 확인
    for _ in range(arrA_len):
        if arrA == arrB:
            return True
        arrA = rotate(arrA)
    return False
```

------

### 가로등

> 길이가 l인 도로에 가로등이 여러대 놓여 있습니다. 전체 도로를 밝히기 위해 좌/우 각각 d만큼을 밝히는 전구를 사려고합니다. 이때 d 값이 충분히 크다면 전체 도로를 밝게 비출 수 있지만, d 값이 작다면 일부 도로는 빛이 닿지 않습니다.

![img](https://res.cloudinary.com/df5yiyxog/image/upload/c_scale,w_450/v1500617953/%EA%B0%80%EB%A1%9C%EB%93%B1_%EC%95%88%EC%A0%95%EB%8B%B5_hcxgr2.png)

> 도로 길이 l과 가로등의 위치 v가 주어졌을 때, 도로를 모두 밝히는 d 값 중 최솟값을 구해주세요.

시간 복잡도를 고려해 최적값을 찾아낼 수 있는지 물어보는 문제입니다. 시간 복잡도를 고려하지 않고 나이브하게 풀었다면 효율성 테스트케이스를 맞추지 못했을겁니다.

권장 Timecomplexity: O( nlogn )

▼ 정답 예시(소팅 & 그리디) - O( nlogn )

```
def solution(l, v):
    v.sort()
    ans = max(v[0], l - v[-1])
    for i in range(1, len(v)):
        ans = max(ans, (v[i] - v[i-1] + 1)//2)
    return ans
```

▼ 정답 예시(이분탐색) - O( nlogn )

```
def solution(l, v):    
    n = len(v)
    answer = l
    v.sort()

    left, right = 0, l
    while(left <= right) :
        mid = (left + right) // 2

        # 맨 앞 가로등과 맨 뒤 가로등이 도로의 양 끝을 밝히는지 확인
        if v[0] - mid > 0 or v[n-1] + mid < l :
            left = mid + 1
            continue

        # 나머지 가로등으로 이분 탐색
        flag = False
        for i in range(1, n) :
            if v[i-1] + mid < v[i] - mid :
                flag = True
                break
        if flag :
            left = mid + 1
        else :
            answer = mid 
            right = mid - 1
    return answer
```

------

### 빙고

> 빙고 게임 보드에 적힌 숫자가 담겨있는 배열 board, 게임 보드에서 순서대로 지운 숫자가 들어있는 배열 nums가 매개변수로 주어질 때, board에서 nums에 들어있는 숫자를 모두 지우면 몇 개의 빙고가 만들어지는지 return하도록 solution함수를 완성해주세요.

![img](https://res.cloudinary.com/dpxurmkij/image/upload/c_scale,w_350/v1496257283/%EB%B9%99%EA%B3%A0_xibpii.png)

수학적 사고력을 해야 풀 수 있는 문제입니다. 이 문제를 풀려면 다음 두가지 일을 해야합니다.

**step 1**. board에 있는 nums의 원소 찾아 마크
**step 2**. board에 가로 / 세로 / 대각선을 확인해 빙고 체크

이때, **step1**에서 hash/set을 이용해 O( n3 )이 아닌 O( n2 ) 코드를 짜는 것이 관건입니다.

권장 Time complexity: O( n2 )

▼ 정답 예시

```
def solution(board, nums):
    n = len(board)
    vertical = [0 for _ in range(n)]
    horizontal = [0 for _ in range(n)]
    lu_diag = 0
    ru_diag = 0

    # 탐색을 O(1)로 하기 위해 nums를 set 자료구조로 변환
    nums = set(nums)
    for p in range(n):
        for q in range(n):
            if board[p][q] in nums:
                horizontal[q]+=1
                vertical[p]+=1
                if p == q:
                    lu_diag+=1
                if p + q == n - 1:
                    ru_diag += 1

    cnt = 0
    cnt += vertical.count(n)
    cnt += horizontal.count(n)
    if lu_diag == n:
        cnt += 1
    if ru_diag == n:
        cnt += 1
    return cnt
```