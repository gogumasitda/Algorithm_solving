**문제설명**

배열의 회전이란 모든 원소를 오른쪽으로 한 칸씩 이동시키고, 마지막 원소는 배열의 맨 앞에 넣는 것을 말합니다.
![569815284.94.png](https://grepp-programmers.s3.amazonaws.com/files/production/15c8c589dc/d85f1290-7dc2-4b3f-9047-bda299c47755.png)

두 배열 arrA와 arrB가 매개변수로 주어질 때, arrA를 회전해 arrB로 만들 수 있으면 true를, 그렇지 않으면 false를 return 하는 solution 함수를 작성해주세요.

##### 제한 조건

- arrA는 길이가 1 이상 1,500 이하인 배열입니다.
  - arrA의 원소는 0 이상 1,500 이하인 정수입니다.
- arrB는 길이가 1 이상 1,500 이하인 배열입니다
  - arrB의 원소는 0 이상 1,500 이하인 정수입니다.

##### 입출력 예

| arrA         | arrB         | return |
| ------------ | ------------ | ------ |
| [7, 8, 10]   | [10, 7, 8]   | true   |
| [4, 3, 2, 1] | [5, 4, 1, 2] | false  |

##### 입출력 예 설명

예시 #1
arrA 배열을 한 번 회전하면 arrB와 같아집니다.

예시 #2
arrA 배열은 아무리 회전해도 arrB와 같지 않습니다.







###### 문제 설명

서울시에 일직선 모양의 새로운 도로가 생겼습니다. 새로운 도로의 전체 길이는 l이고 도로에는 총 n개의 가로등이 세워졌습니다. 이 도로의 모든 가로등에 전구를 사서 달려고 합니다. 전구를 선택하는 기준은 다음과 같습니다.

1. 전구는 길의 좌측, 우측 방향으로 각각 d 길이만큼 길을 밝힐 수 있고, **d는 자연수**입니다.
2. 모든 가로등에는 같은 종류(d 값이 같은)의 전구를 달아야 합니다.
3. 안전을 위하여 도로위에 어두운 부분이 있어서는 안 됩니다.

이때, d 값이 충분히 크다면 전체 도로를 밝게 비출 수 있지만, d 값이 작아진다면 도로 위에 빛이 닿지 않는 부분이 생길 수도 있습니다. 따라서, 도로 위에 어두운 부분이 생기지 않도록 하는 d 값 중 최솟값을 구하려고 합니다. 전체 도로의 길이 l, 가로등이 세워져 있는 위치가 들어있는 배열 v가 매개변수로 주어질 때, 위의 모든 조건을 만족하는 d 의 최솟값을 return 하도록 solution 함수를 완성해주세요.

##### 제한사항

- l은 1 이상 1,000,000,000 이하의 자연수입니다.
- v에는 가로등의 위치정보가 들어있습니다.
- 가로등의 위치는 0 이상 l 이하의 정수이며, 같은 위치에 2개 이상의 가로등이 있는 경우는 주어지지 않습니다.
- 가로등의 개수는 1이상 1,000 이하의 자연수입니다.

------

##### 입출력 예

| l    | v                 | output |
| ---- | ----------------- | ------ |
| 15   | [15,5,3,7,9,14,0] | 3      |
| 5    | [2,5]             | 2      |

##### 입출력 예 설명

입출력 예 #1
d가 3보다 작은 경우(아래 그림의 경우 d = 2) 다음과 같이 밝히지 못하는 부분이 생기게 됩니다.

![image](https://res.cloudinary.com/df5yiyxog/image/upload/c_scale,w_450/v1500617953/%EA%B0%80%EB%A1%9C%EB%93%B1_%EC%95%88%EC%A0%95%EB%8B%B5_hcxgr2.png)

따라서 모든 길을 밝게 비추기 위한 d의 최솟값은 3이 됩니다.

입출력 예 #2
d가 2보다 작은 경우(아래 그림의 경우 d = 1) 다음과 같이 2 위치에 있는 가로등이 길의 시작 부분을 밝히지 못하게 됩니다.

![image](https://res.cloudinary.com/df5yiyxog/image/upload/c_scale,w_300/v1500618172/%EA%B0%80%EB%A1%9C%EB%93%B1_%EC%95%88%EC%A0%95%EB%8B%B52_v630en.png)

따라서 모든 길을 밝게 비추기 위한 d의 최솟값은 2가 됩니다.













###### 문제 설명

빙고는 NxN 크기의 게임 보드 칸에 1부터 NxN까지의 자연수를 중복 없이 하나씩 적은 후 숫자를 하나씩 지워나가는 게임입니다. 이때, 가로, 세로, 대각선 방향으로 한 줄에 적힌 숫자를 모두 지울 경우 빙고를 1개 만들었다고 합니다.
다음은 4X4 크기의 게임 보드를 이용해 게임을 진행한 예시입니다.

![image](https://res.cloudinary.com/dpxurmkij/image/upload/c_scale,w_280/v1496257284/%EB%B9%99%EA%B3%A02_rlkqli.png)

위와 같이 각 칸에 숫자가 적혀 있을 때, 위 게임 보드에서 순서대로 지운 숫자가 [14,3,2,4,13,1,16,11,5,15]인 경우 아래와 같이 빙고 3개가 만들어집니다.

![image](https://res.cloudinary.com/dpxurmkij/image/upload/c_scale,w_350/v1496257283/%EB%B9%99%EA%B3%A0_xibpii.png)

빙고 게임 보드에 적힌 숫자가 담겨있는 배열 board, 게임 보드에서 순서대로 지운 숫자가 들어있는 배열 nums가 매개변수로 주어질 때, board에서 nums에 들어있는 숫자를 모두 지우면 몇 개의 빙고가 만들어지는지 return하도록 solution함수를 완성해주세요.

##### 제한사항

- board는 게임 보드 칸에 적힌 숫자를 뜻하는 NxN크기의 2차원 배열이며, N은 2 이상 500이하의 자연수입니다.
- board의 각 칸에는 1 이상 NxN이하의 자연수가 중복 없이 하나씩 들어있습니다.
- nums는 board에서 지울 숫자가 들어있는 배열이며, 길이는 1 이상 NxN이하입니다.
- nums에 들어있는 숫자는 1 이상 NxN이하의 자연수이며, 중복된 수가 들어있지 않습니다.

------

##### 입출력 예

| board                                                        | nums                                | result |
| ------------------------------------------------------------ | ----------------------------------- | ------ |
| [[11,13,15,16],[12,1,4,3],[10,2,7,8],[5,14,6,9]]             | [14,3,2,4,13,1,16,11,5,15]          | 3      |
| [[6,15,17,14,23],[5,12,16,13,25],[21,4,2,1,22],[10,20,3,18,8],[11,9,19,24,7]] | [15,7,2,25,9,16,12,18,5,4,10,13,20] | 2      |

##### 입출력 예 설명

입출력 예 #1
문제의 예시와 같습니다.

입출력 예 #2
다음 그림과 같이 2개의 빙고가 만들어집니다.
![image](https://res.cloudinary.com/dpxurmkij/image/upload/c_scale,w_250/v1496258193/%EB%B9%99%EA%B3%A03_l1bqza.png)