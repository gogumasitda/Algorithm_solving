# C_19.01.06_Pointer

## 포인터

> 메모리 상에 위치한 특정한 데이터의 주소값을 보관하는 변수
>
> 포인터 역시 데이터 형(type)를 가진다



##### 	포인터의 선언

```c++
// (포인터에 주소값이 저장되는 데이터의 형) *(포인터의 이름);
// (포인터에 주소값이 저장되는 데이터의 형)* (포인터의 이름);
int *p;  // 라고 하거나
int* p;  // 로 하면 된다
```

`int` 형 데이터의 주소값을 저장하는 포인터 p 생성

## & 연산자

> 데이터의 주소값을 알기위해 사용하는 연산자
>
> 단항 연사자로써 사용한다.

​	사용법

```c++
// & (주소값을 계산할 데이터)
```

##### 	예제 코드

```c
/* & 연산자 */
#include <stdio.h>
int main() {
  int a;
  a = 2;

  printf("%p \n", &a);
  return 0;
}
```



##### 	포인터와 & 연산자 사용

```c
/* 포인터의 시작 */
#include <stdio.h>
int main() {
  int *p;
  int a;

  p = &a;

  printf("포인터 p 에 들어 있는 값 : %p \n", p);
  printf("int 변수 a 가 저장된 주소 : %p \n", &a);

  return 0;
}
```



##### 	출력 결과

```
포인터 p 에 들어 있는 값 : 2efca0
int 변수 a 에 들어 있는 값 : 2efca0
```

둘의 값은 같게 나온다.

```c
p = &a;
```

여기서 a의 주소를 포인터 p에 대입하였기 때문에.



## * 표

> *포인터 의 의미는 포인터에 저장된 주소값에 위치한 데이터를 의미



##### 	예제

```c
/* * 연산자의 이용 */
#include <stdio.h>
int main() {
  int *p;
  int a;

  p = &a;
  a = 2;

  printf("a 의 값 : %d \n", a);
  printf("*p 의 값 : %d \n", *p);

  return 0;
}
```



##### 	출력 결과

```
a 의 값 : 2
*p 의 값 : 2
```



##### 	예제2

```c
/* * 연산자 */
#include <stdio.h>

int main() {
    int *p;
    int a;
    
    p = &a;
    *p = 3;
    
    printf("a의 값 : %d \n", a);
    printf("*p 의 값 : %d \n", *p);
    
    return 0      
}
```



##### 	실행 결과

```
a 의 값 : 3
*p 의 값 : 3
```



```c
p = &a; // a의 주소값을 p에 넣고
*p = 3; // 저장된 주소값에 3을 넣는다.
```



## 포인터가 데이터 형을 가지는 이유

1. 포인터는 가리키는 데이터의 시작 주소값을 갖는다.
2. 해당 데이터의 자료형을 제외하고는 포인터는 데이터의 어떤 정보도 갖기 못한다.
3. 만약 포인터가 데이터 형을 가지지 못한다면 자신이 가리킨 변수의 값을 수정할 때 해당 변수가 메모리에서 차지하고 있는 범위를 알 방법이 없다.



## 문제

`int **a`와 같은 이중 포인터에 대해 생각해보자.



##### 	내 생각

- 포인터의 주소값을 받아오는 포인터